/*
 * Utility to take a keyboard .script file and generate any necessary 
 * C++ arrays. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <fstream>
#include <vector>
#include <sstream>
#include <algorithm>

using namespace std; 

struct LanguageData
{
    string key_code; 
    char32_t normal; 
    char32_t shifted;
};

vector<LanguageData> language_key_mappings;

struct ScancodeData
{
    string keyboard_key_code; 
    uint8_t scancode; 
};

vector<ScancodeData> scancode_mappings;

void usage()
{
    printf("usage: keyboard_data_gen -k | -l <input_script> <output_cpp_file>\n"); 
    printf("Keyboard script files have // double slashes as comments.\n"); 
    printf("-s - process a scan code map between a keyboard and KeyboardKeyCodes\n"); 
    printf("-l - process a language file mapping KeyboardKeyCodes to unicode characters\n"); 
    exit(1); 
}

vector<string> get_split_strings(const string & source)
{
    string new_string; 
    vector<string> result;

    auto a = source.begin(); 

    while (a != source.end())
    {
        if (! isspace(*a))
            new_string += *a;
        else
            if (new_string.size() > 0)
            {
                result.push_back(new_string); 
                new_string.clear(); 
            }

        a++;
    }

    if (new_string.size() > 0)
        result.push_back(new_string); 

    return result; 
}


bool is_positive_integer(const string & s)
{
    return ! s.empty() && find_if(s.begin(), s.end(), [](char c) 
            { 
                return ! std::isdigit(c); 
            }) == s.end();
}

char32_t get_unicode_for_utf8(const string & s)
{
    if ((s[0] & 0x80) == 0)
        return s[0];

    /* insert rest of utf8 decoding here. */
    return 0; 
}

/** 
 * If the string has mutiple characters then treat it as the character
 * number.  Otherwise just take the character number. 
 */
char32_t get_unicode_character_from_string(const string & s)
{
    if ((s.size() > 1) && is_positive_integer(s))
        return (char32_t) stoul(s); 
    else
        return get_unicode_for_utf8(s);
}

LanguageData get_language_data(char * buf)
{
    vector<string> fields = get_split_strings(buf);

    if (fields.size() == 0)
    {
        cout << "error: invalid line" << endl << buf << endl;
        exit(1); 
    }

    LanguageData d; 
    d.key_code = fields[0];

    if (fields.size() == 1)
    {
        d.normal = 0; 
        d.shifted = 0;
    }

    if (fields.size() == 2)
    {
        d.normal = get_unicode_character_from_string (fields[1]);
        d.shifted = d.normal;
    }

    if (fields.size() == 3)
    {
        d.normal = get_unicode_character_from_string (fields[1]);
        d.shifted = get_unicode_character_from_string (fields[2]);
    }

    return d;
}

void write_language_arrays(char * output_filename)
{
    ofstream of {output_filename};
    const char * key_mapping_name = "keymap_uk"; 

    of << "/* Keyboard mapping data.  Created by keyboard_data_gen from a script file. */" << endl;
    of << "KeyAttributes " << key_mapping_name << "[] = {" << endl;
    bool first_time = true;

    for (auto m: language_key_mappings)
    {
        if (! first_time)
            of << "," << endl;

        of << "    { " << m.key_code << ", " << m.normal << ", " << m.shifted << " }"; 

        first_time = false; 
    }

    of << endl << "};" << endl;
}

ScancodeData get_scancode_data(char * buf)
{
    vector<string> fields = get_split_strings(buf);

    if (fields.size() == 0)
    {
        cout << "error: invalid line" << endl << buf << endl;
        exit(1); 
    }

    ScancodeData d;
    if (fields.size() == 2)
    {
        try
        {
            d.scancode = std::stoul(fields[1].c_str(), nullptr, 16);
        }
        catch (const std::invalid_argument & s)
        {
            cout << "ERROR IN FILE ON LINE:" << endl; 
            cout << buf << endl; 
            exit(1);
        }
            
        d.keyboard_key_code = fields[0];
    }
    else
    {
        d.scancode = 0xFF;
        d.keyboard_key_code = "K_NONE";
    }

    return d;
};

/** The output in scancode mode is a table which maps scancodes to keyboard codes. 
 *
 * This allows keys that generate a single scancode to be looked up quickly and using the minimum 
 * amount of memory. 
 *
 * A special flag and a second lookup table will be used as and when we need to support 
 * keys that generate multiple scancode. 
 *
 * There must be exactly 128 scancode entries. 
 * */

void write_scancode_arrays(char * output_filename)
{
    ofstream of {output_filename};
    const char * scancode_mapping_name = "mac_scancode_map";

    of << "/* Scancode data generated by keyboard_data_gen from a script file. */" << endl; 
    of << "KeyboardKeyCode " << scancode_mapping_name << "[] = {" << endl; 
    

    for (int i = 0; i < 128; ++i)
    {
        if (i != 0)
            of << "," << endl;

        auto entry = std::find_if(scancode_mappings.begin(), scancode_mappings.end(), [i](const ScancodeData & v) { return v.scancode == i; }); 
        if (entry != scancode_mappings.end())
            of << "    " << entry->keyboard_key_code;
        else 
            of << "    " << "K_NONE"; 
    }

    of << endl << "};" << endl;
}

enum Mode
{
    kScanCodeMode,
    kLanguageMode
} mode;


int main(int argc, char ** argv)
{
    if (argc != 4) 
        usage(); 


    int is_lang = strcmp(argv[1], "-l"); 
    int is_scan = strcmp(argv[1], "-s"); 

    if (is_lang == 0)
        mode = kLanguageMode; 
    else if (is_scan == 0)
        mode = kScanCodeMode;
    else
        usage(); 

    FILE * f = fopen(argv[2], "r");
    const int count = 200; 
    char buf[count];

    while (fgets(buf, count, f) != 0)
    {
        /* Terminate the string at the location of a comment. */
        char * comment_position = strstr(buf, "//"); 
        
        if (comment_position) 
            *comment_position = 0;

        /* Ignore blank lines. */
        char *end_of_whitepace = buf; 

        while (isspace(*end_of_whitepace))
            end_of_whitepace++;

        if (*end_of_whitepace == '\0')
            continue;

        if (mode == kLanguageMode)
            language_key_mappings.push_back(get_language_data(buf)); 
        else if (mode == kScanCodeMode)
            scancode_mappings.push_back(get_scancode_data(buf)); 

    }

    fclose(f); 

    if (mode == kLanguageMode)
        write_language_arrays(argv[3]); 
    else if (mode == kScanCodeMode)
        write_scancode_arrays(argv[3]); 
    
    return 0;
}   

