#pragma once

#include <keyboard/kb_scancodes.h>
#include <hw/device.h>

/** @file
 * This set of classes and data can take a stream from the KeyboardHardware driver
 * and translate it into a stream of events which include characters as well as 
 * special keys and modifier keys that an application can use relatively easily.
 *
 * It allows for changing the language on a keyboard. 
 */

/** Keymapping describes the characters and functions of keys on the keyboard. 
 * This needs to be in the order defined by the keyboard map generation utility.
 * 
 */
struct KeyAttributes
{
    KeyboardKeyCode key_code; 
    char32_t key_without_shift;
    char32_t key_with_shift; 
};

typedef KeyAttributes KeyMappingArray;

/** Import the KeyboardKeyCode mappings to KeyAttributes information. */


struct Modifiers
{
    bool shift; 
    bool control; 
    bool alt; 

    bool operator==(const Modifiers & rhs) const
    {
        return (shift == rhs.shift) &&
            (control == rhs.control) &&
            (alt == rhs.alt); 
    }
};
/** 
 * Describes an event generated by the keyboard driver when a key is pressed. 
 */
struct KeyEvent
{
    KeyEvent()
    {
        *this = invalid; 
    }
    KeyEvent(KeyboardKeyCode key_code, Modifiers modifiers, char32_t character_representation)
        :
            key_code(key_code),
            modifiers(modifiers),
            character(character_representation)
    {}

    KeyboardKeyCode key_code;
    Modifiers modifiers;
    char32_t character; 

    bool is_alpha() const
    {
        return (character >= 'A' && character <= 'Z');
    }

    bool is_control_character() const
    {
        return (character < ' ');
    }

    bool operator==(const KeyEvent & rhs) const
    {
        return (key_code == rhs.key_code) &&
            (modifiers == rhs.modifiers) &&
            (character == rhs.character); 
    }
    bool operator!=(const KeyEvent & rhs) const
    {
        return ! operator==(rhs); 
    }

    bool is_enter_or_return() const
    {
        return key_code == K_ENTER; 
    }

    bool is_backspace() const
    {
        return key_code == K_BACKSPACE; 
    }

    const static KeyEvent invalid; 
};

/**
 * Provides the link between the KeyboardHardware and the queue of KeyEvents
 *
 */
class KeyEventManager
{
    public:
        KeyEventManager();
        /** Return the next keyboard event.  Returns KeyEvent::invalid
         * if there are no events pending. */
        KeyEvent next();
    private:
        void update_modifiers(KeyboardKeyCode, bool is_key_up); 


        bool lctrl; 
        bool rctrl; 

        bool lshift; 
        bool rshift; 

        Modifiers current_modifiers;
        Device * keyboard; 
};
